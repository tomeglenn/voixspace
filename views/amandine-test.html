{% extends "layout.html" %}

{% block head %}
<style>
  body {
    font-family: Monospace;
    background-color: #f0f0f0;
    margin: 0px;
    overflow: hidden;
  }
</style>

<script src="/public/js/TrackballControls.js"></script>
<script src="/public/js/Detector.js"></script>
<script src="/public/js/Bird.js"></script>
<script src="/public/js/Boid.js"></script>

  <script>
    window.onload = function () {

      var mouseX = 0;
      var mouseY = 0;
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;
      var radius = 100, theta = 0;
      var angle = 0;
      
      // SCENE
      var scene = new THREE.Scene();
      scene.background = new THREE.Color( 0x0F6A7A );
      scene.add( new THREE.AmbientLight( 0xffffff, 0.3 ) );

      // LIGHT
      var light = new THREE.DirectionalLight( 0xffffff, 0.35 );
      light.position.set( 1, 1, 1 ).normalize();
      scene.add( light );

      // CAMERA
      var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
      camera.position.x = 0;
      camera.position.z = -5;

      // CONTROLS FOR CAMERA DRAG
      var controls = new THREE.TrackballControls(camera);
      controls.rotateSpeed = 10.0;
      controls.zoomSpeed = 10;
      controls.noZoom = false;
      controls.noPan = true;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 1;
      controls.keys = [ 65, 83, 68 ];
      controls.addEventListener( 'change', render );

      // RENDERER
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      // STARS
      var stars = [];
      var geometry = new THREE.SphereBufferGeometry( 0.2, 64, 32 );
      var material = new THREE.MeshBasicMaterial( { color: 0x32A188, wireframe: true } );
      
      for(var i=0; i<1000; i++){
        var cube = new THREE.Mesh( geometry, material );
        cube.position.x = Math.random() * 360 - 180;
        cube.position.y = Math.random() * 360 - 180;
        cube.position.z = Math.random() * 360 - 180;
        cube.scale.x = cube.scale.y = cube.scale.z = Math.random() * 3 + 1;

        scene.add( cube );
        stars[i] = cube;
      }   

      // BIRDS
      var birds = [];
      var boids = [];
      for ( var i = 0; i < 200; i ++ ) {
        boid = boids[ i ] = new Boid();
        boid.position.x = Math.random() * 400 - 200;
        boid.position.y = Math.random() * 400 - 200;
        boid.position.z = Math.random() * 400 - 200;
        boid.velocity.x = Math.random() * 2 - 1;
        boid.velocity.y = Math.random() * 2 - 1;
        boid.velocity.z = Math.random() * 2 - 1;
        boid.setAvoidWalls( true );
        boid.setWorldSize( 500, 500, 400 );
        bird = birds[ i ] = new THREE.Mesh( new Bird(), new THREE.MeshBasicMaterial( { color:Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
        bird.phase = Math.floor( Math.random() * 62.83 );
        scene.add( bird );
      }

      function render() {  
        for ( var i = 0, il = birds.length; i < il; i++ ) {
            boid = boids[ i ];
            boid.run( boids );
            bird = birds[ i ];
            bird.position.copy( boids[ i ].position );
            color = bird.material.color;
            color.r = color.g = color.b = ( 500 - bird.position.z ) / 1000;
            bird.rotation.y = Math.atan2( - boid.velocity.z, boid.velocity.x );
            bird.rotation.z = Math.asin( boid.velocity.y / boid.velocity.length() );
            bird.phase = ( bird.phase + ( Math.max( 0, bird.rotation.z ) + 0.1 )  ) % 62.83;
            bird.geometry.vertices[ 5 ].y = bird.geometry.vertices[ 4 ].y = Math.sin( bird.phase ) * 5;
        }

      	renderer.render( scene, camera );
      }

      function animate() {
        // CAMERA DRAG
        requestAnimationFrame( animate );
        controls.update();

        // CAMERA SPAN
        theta += 0.01;
        camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) );
        camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) );
        camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) );
      }

      // WINDOW RESIZE
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
        render();
			}
      window.addEventListener( 'resize', onWindowResize, false );      

      render();
      animate();
    };
  </script>
  {% endblock %}
{% block body %}
{% endblock %}