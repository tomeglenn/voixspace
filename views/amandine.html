{% extends "layout.html" %}

{% block head %}

<style>
  body {
    font-family: Monospace;
    background-color: #f0f0f0;
    margin: 0px;
    overflow: hidden;
  }
</style>

  <script>
    
    window.onload = function () {

      document.addEventListener( 'mousemove', onDocumentMouseMove, false );
      var mouseX = 0;
      var mouseY = 0;
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;
      
      // SCENE
      var scene = new THREE.Scene();
      scene.background = new THREE.Color( 0x0F6A7A );
      scene.add( new THREE.AmbientLight( 0xffffff, 0.3 ) );

      // LIGHT
      var light = new THREE.DirectionalLight( 0xffffff, 0.35 );
      light.position.set( 1, 1, 1 ).normalize();
      scene.add( light );

      // CAMERA
      var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
      camera.position.z = 5;

      // RENDERER
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      // GEOMETRY
      var shapes = [];
      var geometry = new THREE.SphereBufferGeometry( 0.1, 32, 16 ); //new THREE.BoxGeometry( 1, 1, 1 );
      var material = new THREE.MeshBasicMaterial( { color: 0x32A188, wireframe: true } );
      
      for(var i=0; i<500; i++){
        var cube = new THREE.Mesh( geometry, material );
        cube.position.x = Math.random() * 360 - 180;
        cube.position.y = Math.random() * 360 - 180;
        cube.position.z = Math.random() * 360 - 180;
        cube.scale.x = cube.scale.y = cube.scale.z = Math.random() * 3 + 1;

        scene.add( cube );
        shapes[i] = cube;
      }   

      function render() {
        
        // SHAPES ANIMATION
        // for(var i=0; i<shapes.length; i++){
        //   shapes[i].rotation.x = Math.random() * 5;
        //   shapes[i].rotation.y = Math.random() * 5;
        // }
      
        // CAMERA FOLLOWS MOUSE
        requestAnimationFrame( render );
        camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

      	renderer.render( scene, camera );
      }

      // CAMERA FOLLOWS MOUSE
      function onDocumentMouseMove(event) {        
			  mouseX = ( event.clientX - windowHalfX ) / 100;
				mouseY = ( event.clientY - windowHalfY ) / 100;
			}

      render();
    };
  </script>
{% endblock %}
{% block body %}
{% endblock %}
